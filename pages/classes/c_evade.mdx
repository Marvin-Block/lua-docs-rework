# c_evade

## Functions

### is_position_safe

#### Arguments

| Argument      | Type      | Required |
|---------------|-----------|----------|
| position      | `vec3`    | +        |
| safe_distance | `boolean` | +        |
| returns       | `boolean` |          |


```lua
local in_safe_spot = features.evade:is_position_safe(g_local.position, true)

if not in_safe_spot then
  print("You are not in a safe spot!")
end
```

### is_active

#### Arguments

| Argument      | Type      | Required |
|---------------|-----------|----------|
| returns       | `boolean` |          |

```lua
if features.evade:is_active() then
    print("currently evading")
end
```

### get_safe_position

#### Arguments

| Argument | Type   | Required |
|----------|--------|----------|
| returns  | `vec3` |          |


```lua
local safe_position = features.evade:get_safe_position()

if safe_position ~= nil then
    g_input:issue_order_move(safe_position)
end
```

### disable_this_tick

Disables evade for the current tick.

```lua
features.evade:disable_this_tick()
```

### get_dangerous_spells

#### Arguments

| Argument | Type                      | Required |
|----------|---------------------------|----------|
| returns  | `table<spell_instance_t>` |          |

```lua
local dangerous_spells = features.evade:get_dangerous_spells()

for _, spell in pairs(dangerous_spells) do
    print(spell.spell_name)
end
```
